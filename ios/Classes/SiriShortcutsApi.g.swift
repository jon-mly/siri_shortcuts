// Autogenerated from Pigeon (v4.2.3), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif


/// Generated class from Pigeon.

enum CreateShortcutStatus: Int {
  case cancelled = 0
  case added = 1
  case deleted = 2
  case updated = 3
}

///Generated class from Pigeon that represents data sent in messages.
struct CreateShortcutResult {
  var status: CreateShortcutStatus
  var phrase: String? = nil
  var errorMessage: String? = nil

  static func fromMap(_ map: [String: Any?]) -> CreateShortcutResult? {
    let status = CreateShortcutStatus(rawValue: map["status"] as! Int)!
    let phrase = map["phrase"] as? String 
    let errorMessage = map["errorMessage"] as? String 

    return CreateShortcutResult(
      status: status,
      phrase: phrase,
      errorMessage: errorMessage
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "status": status.rawValue,
      "phrase": phrase,
      "errorMessage": errorMessage
    ]
  }
}

///Generated class from Pigeon that represents data sent in messages.
struct ShortcutDetail {
  var activityType: String
  var userInfo: [String?: Any?]

  static func fromMap(_ map: [String: Any?]) -> ShortcutDetail? {
    let activityType = map["activityType"] as! String
    let userInfo = map["userInfo"] as! [String?: Any?]

    return ShortcutDetail(
      activityType: activityType,
      userInfo: userInfo
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "activityType": activityType,
      "userInfo": userInfo
    ]
  }
}

///Generated class from Pigeon that represents data sent in messages.
struct ShortcutOptions {
  /// The activity type associated with the shortcut.
  var activityType: String
  /// The user-visible title for the shortcut.
  var title: String
  /// A human-understandable string that can be used to suggest a voice shortcut phrase to the user.
  var suggestedInvocationPhrase: String? = nil
  /// A map containing app-specific state information needed to continue an activity on another device.
  var userInfo: [String?: Any?]? = nil
  /// The eligibility for the shortcut.
  var eligibility: ShortcutEligibility? = nil
  /// A description for the shortcut.
  var description: String? = nil
  /// The keys from the userInfo property which represent the minimal information
  /// about the shortcut that should be stored for later restoration.
  ///
  /// A null value means all keys are required.
  var requiredUserInfoKeys: [String?]? = nil
  /// Indicates that the state of the activity needs to be updated.
  var needsSave: Bool? = nil
  /// When no suitable application is installed on a resuming device and the webpageURL is set,
  /// the shortcut will instead be continued in a web browser by loading this resource.
  var webpageURL: String? = nil
  /// The URL of the webpage that referred (linked to) [webpageURL].
  var referrerURL: String? = nil
  /// If non-null, then an absolute date after which
  /// the shortcut is no longer eligible to be indexed or handed off.
  var expirationDate: Int32? = nil
  /// A set of keywords, representing words or phrases in the current user's language
  /// that might help the user to find the shortcut in the application history.
  var keywords: [String?]? = nil
  /// A value used to identify the shortcut.
  var persistentIdentifier: String? = nil
  /// The content type of the shortcut's attribute set.
  var contentType: String? = nil

  static func fromMap(_ map: [String: Any?]) -> ShortcutOptions? {
    let activityType = map["activityType"] as! String
    let title = map["title"] as! String
    let suggestedInvocationPhrase = map["suggestedInvocationPhrase"] as? String 
    let userInfo = map["userInfo"] as? [String?: Any?] 
    var eligibility: ShortcutEligibility? = nil
    if let eligibilityMap = map["eligibility"] as? [String: Any?] {
      eligibility = ShortcutEligibility.fromMap(eligibilityMap)
    }
    let description = map["description"] as? String 
    let requiredUserInfoKeys = map["requiredUserInfoKeys"] as? [String?] 
    let needsSave = map["needsSave"] as? Bool 
    let webpageURL = map["webpageURL"] as? String 
    let referrerURL = map["referrerURL"] as? String 
    let expirationDate = map["expirationDate"] as? Int32 
    let keywords = map["keywords"] as? [String?] 
    let persistentIdentifier = map["persistentIdentifier"] as? String 
    let contentType = map["contentType"] as? String 

    return ShortcutOptions(
      activityType: activityType,
      title: title,
      suggestedInvocationPhrase: suggestedInvocationPhrase,
      userInfo: userInfo,
      eligibility: eligibility,
      description: description,
      requiredUserInfoKeys: requiredUserInfoKeys,
      needsSave: needsSave,
      webpageURL: webpageURL,
      referrerURL: referrerURL,
      expirationDate: expirationDate,
      keywords: keywords,
      persistentIdentifier: persistentIdentifier,
      contentType: contentType
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "activityType": activityType,
      "title": title,
      "suggestedInvocationPhrase": suggestedInvocationPhrase,
      "userInfo": userInfo,
      "eligibility": eligibility?.toMap(),
      "description": description,
      "requiredUserInfoKeys": requiredUserInfoKeys,
      "needsSave": needsSave,
      "webpageURL": webpageURL,
      "referrerURL": referrerURL,
      "expirationDate": expirationDate,
      "keywords": keywords,
      "persistentIdentifier": persistentIdentifier,
      "contentType": contentType
    ]
  }
}

///Generated class from Pigeon that represents data sent in messages.
struct ShortcutEligibility {
  /// Set to true if the shortcut should be indexed by App History.
  var search: Bool
  /// Set to true if Siri should suggest the shortcut to users.
  var prediction: Bool
  /// Set to true if the shortcut should be eligible to be handed off to another device.
  var handOff: Bool
  /// Set to true if the shortcut should be eligible for indexing for any user of this application,
  /// on any device, or false if the activity contains private or sensitive information or
  /// which would not be useful to other users if indexed.
  ///
  /// The activity must also have [ShortcutOptions.requiredUserActivityKeys]
  /// or a [ShortcutOptions.webpageURL].
  var publicIndexing: Bool

  static func fromMap(_ map: [String: Any?]) -> ShortcutEligibility? {
    let search = map["search"] as! Bool
    let prediction = map["prediction"] as! Bool
    let handOff = map["handOff"] as! Bool
    let publicIndexing = map["publicIndexing"] as! Bool

    return ShortcutEligibility(
      search: search,
      prediction: prediction,
      handOff: handOff,
      publicIndexing: publicIndexing
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "search": search,
      "prediction": prediction,
      "handOff": handOff,
      "publicIndexing": publicIndexing
    ]
  }
}

private class SiriShortcutsApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return CreateShortcutResult.fromMap(self.readValue() as! [String: Any])      
      case 129:
        return ShortcutEligibility.fromMap(self.readValue() as! [String: Any])      
      case 130:
        return ShortcutOptions.fromMap(self.readValue() as! [String: Any])      
      default:
        return super.readValue(ofType: type)
      
    }
  }
}
private class SiriShortcutsApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? CreateShortcutResult {
      super.writeByte(128)
      super.writeValue(value.toMap())
    } else if let value = value as? ShortcutEligibility {
      super.writeByte(129)
      super.writeValue(value.toMap())
    } else if let value = value as? ShortcutOptions {
      super.writeByte(130)
      super.writeValue(value.toMap())
    } else {
      super.writeValue(value)
    }
  }
}

private class SiriShortcutsApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return SiriShortcutsApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return SiriShortcutsApiCodecWriter(data: data)
  }
}

class SiriShortcutsApiCodec: FlutterStandardMessageCodec {
  static let shared = SiriShortcutsApiCodec(readerWriter: SiriShortcutsApiCodecReaderWriter())
}

///Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol SiriShortcutsApi {
  func createShortcut(options: ShortcutOptions, completion: @escaping (CreateShortcutResult) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class SiriShortcutsApiSetup {
  /// The codec used by SiriShortcutsApi.
  static var codec: FlutterStandardMessageCodec { SiriShortcutsApiCodec.shared }
  /// Sets up an instance of `SiriShortcutsApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: SiriShortcutsApi?) {
    let createShortcutChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.SiriShortcutsApi.createShortcut", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createShortcutChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let optionsArg = args[0] as! ShortcutOptions
        api.createShortcut(options: optionsArg) { result in
          reply(wrapResult(result))
        }
      }
    } else {
      createShortcutChannel.setMessageHandler(nil)
    }
  }
}
private class SiriShortcutsFlutterApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return ShortcutDetail.fromMap(self.readValue() as! [String: Any])      
      default:
        return super.readValue(ofType: type)
      
    }
  }
}
private class SiriShortcutsFlutterApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? ShortcutDetail {
      super.writeByte(128)
      super.writeValue(value.toMap())
    } else {
      super.writeValue(value)
    }
  }
}

private class SiriShortcutsFlutterApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return SiriShortcutsFlutterApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return SiriShortcutsFlutterApiCodecWriter(data: data)
  }
}

class SiriShortcutsFlutterApiCodec: FlutterStandardMessageCodec {
  static let shared = SiriShortcutsFlutterApiCodec(readerWriter: SiriShortcutsFlutterApiCodecReaderWriter())
}

///Generated class from Pigeon that represents Flutter messages that can be called from Swift.
class SiriShortcutsFlutterApi {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return SiriShortcutsFlutterApiCodec.shared
  }
  func onShortcutTriggered(detail detailArg: ShortcutDetail, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.SiriShortcutsFlutterApi.onShortcutTriggered", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([detailArg]) { _ in
      completion()
    }
  }
}

private func wrapResult(_ result: Any?) -> [String: Any?] {
  return ["result": result]
}

private func wrapError(_ error: FlutterError) -> [String: Any?] {
  return [
    "error": [
      "code": error.code,
      "message": error.message,
      "details": error.details
    ]
  ]
}
