// Autogenerated from Pigeon (v13.0.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)"
  ]
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

enum CreateShortcutStatus: Int {
  case cancelled = 0
  case added = 1
  case deleted = 2
  case updated = 3
}

/// Generated class from Pigeon that represents data sent in messages.
struct CreateShortcutResult {
  var status: CreateShortcutStatus
  var phrase: String? = nil
  var errorMessage: String? = nil

  static func fromList(_ list: [Any?]) -> CreateShortcutResult? {
    let status = CreateShortcutStatus(rawValue: list[0] as! Int)!
    let phrase: String? = nilOrValue(list[1])
    let errorMessage: String? = nilOrValue(list[2])

    return CreateShortcutResult(
      status: status,
      phrase: phrase,
      errorMessage: errorMessage
    )
  }
  func toList() -> [Any?] {
    return [
      status.rawValue,
      phrase,
      errorMessage,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct ShortcutDetail {
  var activityType: String
  var userInfo: [String?: Any?]

  static func fromList(_ list: [Any?]) -> ShortcutDetail? {
    let activityType = list[0] as! String
    let userInfo = list[1] as! [String?: Any?]

    return ShortcutDetail(
      activityType: activityType,
      userInfo: userInfo
    )
  }
  func toList() -> [Any?] {
    return [
      activityType,
      userInfo,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct ShortcutOptions {
  /// The activity type associated with the shortcut.
  var activityType: String
  /// The user-visible title for the shortcut.
  var title: String
  /// A human-understandable string that can be used to suggest a voice shortcut phrase to the user.
  var suggestedInvocationPhrase: String? = nil
  /// A map containing app-specific state information needed to continue an activity on another device.
  var userInfo: [String?: Any?]? = nil
  /// The eligibility for the shortcut.
  var eligibility: ShortcutEligibility? = nil
  /// A description for the shortcut.
  var description: String? = nil
  /// The keys from the userInfo property which represent the minimal information
  /// about the shortcut that should be stored for later restoration.
  ///
  /// A null value means all keys are required.
  var requiredUserInfoKeys: [String?]? = nil
  /// Indicates that the state of the activity needs to be updated.
  var needsSave: Bool? = nil
  /// When no suitable application is installed on a resuming device and the webpageURL is set,
  /// the shortcut will instead be continued in a web browser by loading this resource.
  var webpageURL: String? = nil
  /// The URL of the webpage that referred (linked to) [webpageURL].
  var referrerURL: String? = nil
  /// If non-null, then an absolute date after which
  /// the shortcut is no longer eligible to be indexed or handed off.
  var expirationDate: Int64? = nil
  /// A set of keywords, representing words or phrases in the current user's language
  /// that might help the user to find the shortcut in the application history.
  var keywords: [String?]? = nil
  /// A value used to identify the shortcut.
  var persistentIdentifier: String? = nil
  /// The content type of the shortcut's attribute set.
  var contentType: String? = nil

  static func fromList(_ list: [Any?]) -> ShortcutOptions? {
    let activityType = list[0] as! String
    let title = list[1] as! String
    let suggestedInvocationPhrase: String? = nilOrValue(list[2])
    let userInfo: [String?: Any?]? = nilOrValue(list[3])
    var eligibility: ShortcutEligibility? = nil
    if let eligibilityList: [Any?] = nilOrValue(list[4]) {
      eligibility = ShortcutEligibility.fromList(eligibilityList)
    }
    let description: String? = nilOrValue(list[5])
    let requiredUserInfoKeys: [String?]? = nilOrValue(list[6])
    let needsSave: Bool? = nilOrValue(list[7])
    let webpageURL: String? = nilOrValue(list[8])
    let referrerURL: String? = nilOrValue(list[9])
    let expirationDate: Int64? = isNullish(list[10]) ? nil : (list[10] is Int64? ? list[10] as! Int64? : Int64(list[10] as! Int32))
    let keywords: [String?]? = nilOrValue(list[11])
    let persistentIdentifier: String? = nilOrValue(list[12])
    let contentType: String? = nilOrValue(list[13])

    return ShortcutOptions(
      activityType: activityType,
      title: title,
      suggestedInvocationPhrase: suggestedInvocationPhrase,
      userInfo: userInfo,
      eligibility: eligibility,
      description: description,
      requiredUserInfoKeys: requiredUserInfoKeys,
      needsSave: needsSave,
      webpageURL: webpageURL,
      referrerURL: referrerURL,
      expirationDate: expirationDate,
      keywords: keywords,
      persistentIdentifier: persistentIdentifier,
      contentType: contentType
    )
  }
  func toList() -> [Any?] {
    return [
      activityType,
      title,
      suggestedInvocationPhrase,
      userInfo,
      eligibility?.toList(),
      description,
      requiredUserInfoKeys,
      needsSave,
      webpageURL,
      referrerURL,
      expirationDate,
      keywords,
      persistentIdentifier,
      contentType,
    ]
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct ShortcutEligibility {
  /// Set to true if the shortcut should be indexed by App History.
  var search: Bool
  /// Set to true if Siri should suggest the shortcut to users.
  var prediction: Bool
  /// Set to true if the shortcut should be eligible to be handed off to another device.
  var handOff: Bool
  /// Set to true if the shortcut should be eligible for indexing for any user of this application,
  /// on any device, or false if the activity contains private or sensitive information or
  /// which would not be useful to other users if indexed.
  ///
  /// The activity must also have [ShortcutOptions.requiredUserActivityKeys]
  /// or a [ShortcutOptions.webpageURL].
  var publicIndexing: Bool

  static func fromList(_ list: [Any?]) -> ShortcutEligibility? {
    let search = list[0] as! Bool
    let prediction = list[1] as! Bool
    let handOff = list[2] as! Bool
    let publicIndexing = list[3] as! Bool

    return ShortcutEligibility(
      search: search,
      prediction: prediction,
      handOff: handOff,
      publicIndexing: publicIndexing
    )
  }
  func toList() -> [Any?] {
    return [
      search,
      prediction,
      handOff,
      publicIndexing,
    ]
  }
}

private class SiriShortcutsApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return CreateShortcutResult.fromList(self.readValue() as! [Any?])
      case 129:
        return ShortcutEligibility.fromList(self.readValue() as! [Any?])
      case 130:
        return ShortcutOptions.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class SiriShortcutsApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? CreateShortcutResult {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else if let value = value as? ShortcutEligibility {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? ShortcutOptions {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class SiriShortcutsApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return SiriShortcutsApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return SiriShortcutsApiCodecWriter(data: data)
  }
}

class SiriShortcutsApiCodec: FlutterStandardMessageCodec {
  static let shared = SiriShortcutsApiCodec(readerWriter: SiriShortcutsApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol SiriShortcutsApi {
  func createShortcut(options: ShortcutOptions, completion: @escaping (Result<CreateShortcutResult, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class SiriShortcutsApiSetup {
  /// The codec used by SiriShortcutsApi.
  static var codec: FlutterStandardMessageCodec { SiriShortcutsApiCodec.shared }
  /// Sets up an instance of `SiriShortcutsApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: SiriShortcutsApi?) {
    let createShortcutChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.siri_shortcuts.SiriShortcutsApi.createShortcut", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      createShortcutChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let optionsArg = args[0] as! ShortcutOptions
        api.createShortcut(options: optionsArg) { result in
          switch result {
            case .success(let res):
              reply(wrapResult(res))
            case .failure(let error):
              reply(wrapError(error))
          }
        }
      }
    } else {
      createShortcutChannel.setMessageHandler(nil)
    }
  }
}
private class SiriShortcutsFlutterApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return ShortcutDetail.fromList(self.readValue() as! [Any?])
      default:
        return super.readValue(ofType: type)
    }
  }
}

private class SiriShortcutsFlutterApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? ShortcutDetail {
      super.writeByte(128)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class SiriShortcutsFlutterApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return SiriShortcutsFlutterApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return SiriShortcutsFlutterApiCodecWriter(data: data)
  }
}

class SiriShortcutsFlutterApiCodec: FlutterStandardMessageCodec {
  static let shared = SiriShortcutsFlutterApiCodec(readerWriter: SiriShortcutsFlutterApiCodecReaderWriter())
}

/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol SiriShortcutsFlutterApiProtocol {
  func onShortcutTriggered(detail detailArg: ShortcutDetail, completion: @escaping (Result<Void, FlutterError>) -> Void) 
}
class SiriShortcutsFlutterApi: SiriShortcutsFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return SiriShortcutsFlutterApiCodec.shared
  }
  func onShortcutTriggered(detail detailArg: ShortcutDetail, completion: @escaping (Result<Void, FlutterError>) -> Void)  {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.siri_shortcuts.SiriShortcutsFlutterApi.onShortcutTriggered", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([detailArg] as [Any?]) { _ in
      completion(.success(Void()))
    }
  }
}
